apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    cluster: gke
    provider: google
  name: cluster-google
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.ai/v2
    kind: Cluster
  mode: Pipeline
  pipeline:
  - step: google
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _metadata = lambda suffix: str -> any {
              {
                  name = oxr.metadata.name
                  annotations = {
                      "crossplane.io/external-name" = oxr.metadata.name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + suffix
                  }
              }
          }

          _items = [{
              apiVersion = "container.gcp.m.upbound.io/v1beta1"
              kind = "Cluster"
              metadata = _metadata("cluster")
              spec = {
                  forProvider = {
                      deletionProtection = False
                      location = "us-east1"
                      if oxr.spec.parameters.version:
                          minMasterVersion = oxr.spec.parameters.version
                      initialNodeCount = 1
                      removeDefaultNodePool = True
                      clusterAutoscaling.autoProvisioningDefaults.management = {
                          autoRepair = True
                          autoUpgrade = True
                      }
                  }
                  writeConnectionSecretToRef = {
                      name = oxr.metadata.name + "-cluster"
                  }
              }
          }, {
              apiVersion = "container.gcp.m.upbound.io/v1beta1"
              kind = "NodePool"
              metadata = _metadata("nodepool")
              spec.forProvider = {
                  if oxr.spec.parameters.version:
                      version = oxr.spec.parameters.version
                  initialNodeCount = oxr.spec.parameters.minNodeCount
                  nodeLocations = ["us-east1-b", "us-east1-c", "us-east1-d"]
                  clusterSelector.matchControllerRef = True
                  nodeConfig = {
                      if oxr.spec.parameters.nodeSize == "small":
                          machineType = "e2-standard-2"
                      elif oxr.spec.parameters.nodeSize == "medium":
                          machineType = "e2-standard-4"
                      else:
                          machineType = "e2-standard-16"
                      oauthScopes = ["https://www.googleapis.com/auth/cloud-platform"]
                      taint = [{
                          key = "node.cilium.io/agent-not-ready"
                          value = "true"
                          effect = "NO_EXECUTE"
                      }]
                  }
                  autoscaling = {
                      minNodeCount = oxr.spec.parameters.minNodeCount
                      maxNodeCount = 10
                  }
                  management = {
                      autoRepair = True
                      autoUpgrade = True
                  }
              }
          }, {
              **oxr
              status.clusterName = oxr.metadata.name
              if oxr.metadata.name + "-cluster" in ocds:
                  status.controlPlaneStatus = ocds[oxr.metadata.name + "-cluster"].Resource.status.conditions[0].reason
                  status.field1 = ocds[oxr.metadata.name + "-cluster"].Resource.status.atProvider.clusterIpv4Cidr
              if oxr.metadata.name + "-nodepool" in ocds:
                  status.nodePoolStatus = ocds[oxr.metadata.name + "-nodepool"].Resource.status.conditions[0].reason
          }]

          _gpu_node_size = oxr.spec.parameters?.gpu?.nodeSize or "small"

          if oxr.spec.parameters?.gpu?.enabled:
              _items += [{
                  apiVersion = "container.gcp.m.upbound.io/v1beta1"
                  kind = "NodePool"
                  metadata = {
                      name = oxr.metadata.name + "-gpu"
                      annotations = {
                          "crossplane.io/external-name" = oxr.metadata.name + "-gpu"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-gpu"
                      }
                  }
                  spec.forProvider = {
                      if oxr.spec.parameters.version:
                          version = oxr.spec.parameters.version
                      clusterSelector.matchControllerRef = True
                      nodeLocations = ["us-east1-c"]
                      initialNodeCount = oxr.spec.parameters?.gpu?.minNodeCount or 1
                      nodeConfig = {
                          if _gpu_node_size == "small":
                              machineType = "n1-standard-4"
                              guestAccelerator = [{
                                  type = "nvidia-tesla-t4"
                                  count = 1
                              }]
                          elif _gpu_node_size == "medium":
                              machineType = "a2-highgpu-4g"
                              guestAccelerator = [{
                                  type = "nvidia-tesla-a100"
                                  count = 4
                              }]
                          else:
                              machineType = "a2-highgpu-8g"
                              guestAccelerator = [{
                                  type = "nvidia-tesla-a100"
                                  count = 8
                              }]
                          oauthScopes = ["https://www.googleapis.com/auth/cloud-platform"]
                          labels = {
                              gpu = "true"
                          }
                      }
                      autoscaling = {
                          minNodeCount = oxr.spec.parameters?.gpu?.minNodeCount or 1
                          maxNodeCount = oxr.spec.parameters?.gpu?.maxNodeCount or 10
                      }
                      management = {
                          autoRepair = True
                          autoUpgrade = True
                      }
                  }
              }]

          items = _items
  - step: apps
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        source: |
          crossplane = "2.1.4"
          argocd = "9.4.1"
          dapr = "1.16.8"
          traefik = "39.0.0"
          externalSecrets = "2.0.0"
          cilium = "1.19.0"
          nvidiaGpuOperator = "v25.10.1"
          openFunctionUrl = "https://openfunction.github.io/charts/openfunction-v1.2.0-v0.7.0.tgz"

          oxr = option("params").oxr
          ocds = option("params").ocds

          _metadata = lambda suffix: str -> any {
              {
                  name = oxr.metadata.name
                  annotations = {
                      "crossplane.io/external-name" = oxr.metadata.name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + suffix
                  }
              }
          }

          schema usage:
              _nameSuffix: str
              _kind: str = "Object"
              apiVersion = "protection.crossplane.io/v1beta1"
              kind = "Usage"
              metadata = {
                  name = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "crossplane.io/external-name" = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                  }
              }
              spec = {
                  of = {
                      apiVersion = "container.gcp.m.upbound.io/v1beta1"
                      kind = "Cluster"
                      resourceRef.name = oxr.metadata.name
                  }
                  by = {
                      if _kind == "Object":
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                      elif _kind == "Release":
                          apiVersion = "helm.m.crossplane.io/v1beta1"
                      kind = _kind
                      resourceRef.name = oxr.metadata.name + "-" + _nameSuffix
                  }
              }

          schema chart:
              _name: str
              _chartName?: str
              _chartRepository?: str
              _chartVersion?: str
              _chartUrl?: str
              _namespace: str
              _values?: any
              _providerConfigRefName?: str
              apiVersion = "helm.m.crossplane.io/v1beta1"
              kind = "Release"
              metadata = {
                  name = oxr.metadata.name + "-app-" + _name
                  annotations = {
                      "crossplane.io/external-name" = _name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-" + _name
                  }
              }
              spec = {
                  forProvider = {
                      chart = {
                          if _chartName:
                              name = _chartName
                          else:
                              name = _name
                          if _chartRepository:
                              repository = _chartRepository
                          if _chartVersion:
                              version = _chartVersion
                          if _chartUrl:
                              url = _chartUrl
                      }
                      if _values:
                          values = _values
                      namespace = _namespace
                  }
                  managementPolicies = ["Create", "Update", "Observe"]
                  rollbackLimit = 3
                  if _providerConfigRefName:
                      providerConfigRef = {name = _providerConfigRefName, kind = "ProviderConfig"}
                  else:
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
              }

          schema object:
              _name: str
              _externalName?: str
              _manifest: any
              _references?: []
              apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
              kind = "Object"
              metadata = {
                  name = oxr.metadata.name + "-app-" + _name
                  annotations = {
                      if _externalName:
                          "crossplane.io/external-name" = _externalName
                      else:
                          "crossplane.io/external-name" = _name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-" + _name
                  }
              }
              spec = {
                  if _references:
                      references = _references
                  forProvider.manifest = _manifest
                  providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
              }

          _items = [

              {
                  apiVersion = "helm.m.crossplane.io/v1beta1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-helm"
                      }
                  }
                  spec = {
                      credentials = {
                          secretRef = {
                              namespace = oxr.metadata.namespace
                              key = "kubeconfig"
                              name = oxr.metadata.name + "-cluster"
                          }
                          source = "Secret"
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          identity = {
                              type = "GoogleApplicationCredentials"
                              source = "Secret"
                              secretRef = {
                                  name = "gcp-creds"
                                  namespace = "crossplane-system"
                                  key = "creds"
                              }
                          }
                  }
              }

              {
                  apiVersion = "helm.m.crossplane.io/v1beta1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name + "-local"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-helm-local"
                      }
                  }
                  spec.credentials.source = "InjectedIdentity"
              }

              if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "aws":
                  {
                      apiVersion = "helm.m.crossplane.io/v1beta1"
                      kind = "Release"
                      metadata = {
                          name = oxr.metadata.name + "-cilium"
                          annotations = {
                              "crossplane.io/external-name" = "cilium"
                              "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-cilium"
                          }
                      }
                      spec = {
                          forProvider = {
                              chart = {
                                  name = "cilium"
                                  repository = "https://helm.cilium.io"
                                  version = cilium
                              }
                              set = [
                                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                                      {name = "nodeinit.enabled", value = "true"}
                                      {name = "nodeinit.reconfigureKubelet", value = "true"}
                                      {name = "nodeinit.removeCbrBridge", value = "true"}
                                      {name = "cni.binPath", value = "/home/kubernetes/bin"}
                                      {name = "gke.enabled", value = "true"}
                                      {name = "ipam.mode", value = "kubernetes"}
                                      {
                                          name = "ipv4NativeRoutingCIDR"
                                          if oxr.metadata.name + "-nodepool" in ocds:
                                              value = oxr.status.field1
                                      },
                                      {name = "authentication.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.install.enabled", value = "true"}
                                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "azure":
                                      {name = "aksbyocni.enabled", value = "true"}
                                      {name = "nodeinit.enabled", value = "true"}
                                      {name = "authentication.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.install.enabled", value = "true"}
                              ]
                              namespace = "kube-system"
                          }
                          rollbackLimit = 3
                          providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                      }
                  }
                  usage { _nameSuffix = "cilium", _kind = "Release" }

              {
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-kubernetes"
                      }
                  }
                  spec = {
                      credentials = {
                          secretRef = {
                              key = "kubeconfig"
                              name = oxr.metadata.name + "-cluster"
                              namespace = oxr.metadata.namespace
                          }
                          source: "Secret"
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          identity = {
                              type = "GoogleApplicationCredentials"
                              source = "Secret"
                              secretRef = {
                                  name = "gcp-creds"
                                  namespace = "crossplane-system"
                                  key = "creds"
                              }
                          }
                  }
              }

              if oxr.spec.parameters?.apps?.crossplane?.enabled:
                  chart {
                      _name = "crossplane"
                      _chartRepository = "https://charts.crossplane.io/stable"
                      _chartVersion = crossplane
                      _namespace = "crossplane-system"
                  }
                  usage { _nameSuffix = "crossplane", _kind = "Release" }

              if oxr.spec.parameters?.apps?.argocd?.enabled:
                  chart {
                      _name = "argo-cd"
                      _chartRepository = "https://argoproj.github.io/argo-helm"
                      _chartVersion = argocd
                      _namespace = "argocd"
                      _values = {
                          global.domain = oxr.spec.parameters.apps.argocd.host
                          configs = {
                              secret = {
                                  argocdServerAdminPassword = "$2a$10$m3eTlEdRen0nS86c5Zph5u/bDFQMcWZYdG3NVdiyaACCqoxLJaz16"
                                  argocdServerAdminPasswordMtime = "2021-11-08T15:04:05Z"
                              }
                              cm = {
                                  "application.resourceTrackingMethod" = "annotation"
                                  "timeout.reconciliation" = "60s"
                              }
                              params = {
                                  "server.insecure" = True
                              }
                          }
                          server = {
                              if oxr.spec.parameters?.apps?.traefik?.enabled:
                                  ingress = {
                                      enabled = True
                                      ingressClassName = "traefik"
                                  }
                              extraArgs = ["--insecure"]
                          }
                      }
                  }
                  object {
                      _name = "argo-cd-app"
                      _manifest = {
                          apiVersion = "argoproj.io/v1alpha1"
                          kind = "Application"
                          metadata = {
                              name = "apps"
                              namespace = "argocd"
                              finalizers = ["resources-finalizer.argocd.argoproj.io"]
                          }
                          spec = {
                              project = "default"
                              source = {
                                  repoURL = oxr.spec.parameters.apps.argocd.repoURL
                                  targetRevision = "HEAD"
                                  path = oxr.spec.parameters.apps.argocd.sourcePath
                              }
                              destination = {
                                  server = "https://kubernetes.default.svc"
                                  namespace = oxr.spec.parameters.apps.argocd.destinationNamespace
                              }
                              syncPolicy.automated = {
                                  selfHeal = True
                                  prune = True
                                  allowEmpty = True
                              }
                          }
                      }
                  }
                  usage { _nameSuffix = "argo-cd", _kind = "Release" }
                  usage { _nameSuffix = "argo-cd-app" }

              if oxr.spec.parameters?.apps?.openfunction?.enabled:
                  chart {
                      _name = "openfunction"
                      _chartUrl = openFunctionUrl
                      _namespace = "openfunction"
                      _values = {
                          revisionController.enable = True
                      }
                  }
                  usage { _nameSuffix = "openfunction", _kind = "Release" }

              if oxr.spec.parameters?.apps?.dapr?.enabled:
                  chart {
                      _name = "dapr"
                      _chartRepository = "https://dapr.github.io/helm-charts/"
                      _chartVersion = dapr
                      _namespace = "dapr-system"
                  }
                  usage { _nameSuffix = "dapr", _kind = "Release" }

              if oxr.spec.parameters?.apps?.traefik?.enabled:
                  chart {
                      _name = "traefik"
                      _chartRepository = "https://helm.traefik.io/traefik"
                      _chartVersion = traefik
                      _namespace = "traefik"
                  }
                  usage { _nameSuffix = "traefik", _kind = "Release" }

              if oxr.spec.parameters?.apps?.externalSecrets?.enabled:
                  chart {
                      _name = "external-secrets"
                      _chartRepository = "https://charts.external-secrets.io"
                      _chartVersion = externalSecrets
                      _namespace = "external-secrets"
                      _values = {
                          installCRDs = True
                      }
                  }
                  usage { _nameSuffix = "external-secrets", _kind = "Release" }

              if oxr.spec.parameters?.apps?.nvidia?.enabled:
                  chart {
                      _name = "gpu-operator"
                      _chartRepository = "https://helm.ngc.nvidia.com/nvidia"
                      _chartVersion = nvidiaGpuOperator
                      _namespace = "gpu-operator"
                      _values = {
                          driver.enabled = False
                      }
                  }
                  usage { _nameSuffix = "gpu-operator", _kind = "Release" }

              if oxr.spec.parameters?.apps?.vllm?.enabled:
                  object {
                      _name = "vllm-op-ns"
                      _externalName = "production-stack-system"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "Namespace"
                          metadata = {
                              name = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-cacheservers"
                      _externalName = "cacheservers.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "cacheservers.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "CacheServer", listKind = "CacheServerList", plural = "cacheservers", singular = "cacheserver" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  additionalPrinterColumns = [
                                      { name = "Status", type = "string", jsonPath = ".status.status" }
                                      { name = "Age", type = "date", jsonPath = ".metadata.creationTimestamp" }
                                  ]
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-loraadapters"
                      _externalName = "loraadapters.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "loraadapters.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "LoraAdapter", listKind = "LoraAdapterList", plural = "loraadapters", singular = "loraadapter" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  additionalPrinterColumns = [
                                      { name = "Phase", type = "string", jsonPath = ".status.phase" }
                                      { name = "Age", type = "date", jsonPath = ".metadata.creationTimestamp" }
                                  ]
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-vllmrouters"
                      _externalName = "vllmrouters.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "vllmrouters.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "VLLMRouter", listKind = "VLLMRouterList", plural = "vllmrouters", singular = "vllmrouter" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-vllmruntimes"
                      _externalName = "vllmruntimes.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "vllmruntimes.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "VLLMRuntime", listKind = "VLLMRuntimeList", plural = "vllmruntimes", shortNames = ["vr"], singular = "vllmruntime" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  schema.openAPIV3Schema = {
                                      type = "object"
                                      "x-kubernetes-preserve-unknown-fields" = True
                                      properties.spec = {
                                          type = "object"
                                          "x-kubernetes-preserve-unknown-fields" = True
                                          properties.vllmConfig = {
                                              type = "object"
                                              "x-kubernetes-preserve-unknown-fields" = True
                                              properties.port = {
                                                  type = "integer"
                                                  format = "int32"
                                                  default = 8000
                                              }
                                          }
                                      }
                                  }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-sa"
                      _externalName = "production-stack-controller-manager"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "ServiceAccount"
                          metadata = {
                              name = "production-stack-controller-manager"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-role"
                      _externalName = "production-stack-leader-election-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "Role"
                          metadata = {
                              name = "production-stack-leader-election-role"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          rules = [
                              { apiGroups = [""], resources = ["configmaps"], verbs = ["get", "list", "watch", "create", "update", "patch", "delete"] }
                              { apiGroups = ["coordination.k8s.io"], resources = ["leases"], verbs = ["get", "list", "watch", "create", "update", "patch", "delete"] }
                              { apiGroups = [""], resources = ["events"], verbs = ["create", "patch"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-manager"
                      _externalName = "production-stack-manager-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-manager-role"
                          rules = [
                              { apiGroups = [""], resources = ["configmaps", "persistentvolumeclaims", "secrets", "serviceaccounts", "services"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = [""], resources = ["pods"], verbs = ["get", "list", "watch"] }
                              { apiGroups = ["apps"], resources = ["deployments"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["networking.k8s.io"], resources = ["ingresses"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers", "loraadapters", "vllmrouters", "vllmruntimes"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers/finalizers", "loraadapters/finalizers", "vllmrouters/finalizers", "vllmruntimes/finalizers"], verbs = ["update"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers/status", "loraadapters/status", "vllmrouters/status", "vllmruntimes/status"], verbs = ["get", "patch", "update"] }
                              { apiGroups = ["rbac.authorization.k8s.io"], resources = ["rolebindings", "roles"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-metrics-auth"
                      _externalName = "production-stack-metrics-auth-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-metrics-auth-role"
                          rules = [
                              { apiGroups = ["authentication.k8s.io"], resources = ["tokenreviews"], verbs = ["create"] }
                              { apiGroups = ["authorization.k8s.io"], resources = ["subjectaccessreviews"], verbs = ["create"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-metrics-reader"
                      _externalName = "production-stack-metrics-reader"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-metrics-reader"
                          rules = [{ nonResourceURLs = ["/metrics"], verbs = ["get"] }]
                      }
                  }
                  object {
                      _name = "vllm-op-rb"
                      _externalName = "production-stack-leader-election-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "RoleBinding"
                          metadata = {
                              name = "production-stack-leader-election-rolebinding"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "Role", name = "production-stack-leader-election-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-crb-manager"
                      _externalName = "production-stack-manager-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRoleBinding"
                          metadata = {
                              name = "production-stack-manager-rolebinding"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "ClusterRole", name = "production-stack-manager-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-crb-metrics"
                      _externalName = "production-stack-metrics-auth-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRoleBinding"
                          metadata.name = "production-stack-metrics-auth-rolebinding"
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "ClusterRole", name = "production-stack-metrics-auth-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-svc"
                      _externalName = "production-stack-controller-manager-metrics-service"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "Service"
                          metadata = {
                              name = "production-stack-controller-manager-metrics-service"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                          spec = {
                              ports = [{ name = "https", port = 8443, protocol = "TCP", targetPort = 8443 }]
                              selector = {
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-deploy"
                      _externalName = "production-stack-production-stack-controller-manager"
                      _manifest = {
                          apiVersion = "apps/v1"
                          kind = "Deployment"
                          metadata = {
                              name = "production-stack-production-stack-controller-manager"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/component" = "manager"
                                  "app.kubernetes.io/created-by" = "production-stack"
                                  "app.kubernetes.io/instance" = "production-stack"
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "app.kubernetes.io/part-of" = "production-stack"
                              }
                          }
                          spec = {
                              selector.matchLabels = {
                                  "app.kubernetes.io/component" = "manager"
                                  "app.kubernetes.io/instance" = "production-stack"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                              template = {
                                  metadata.labels = {
                                      "app.kubernetes.io/component" = "manager"
                                      "app.kubernetes.io/instance" = "production-stack"
                                      "app.kubernetes.io/name" = "production-stack"
                                      "control-plane" = "controller-manager"
                                  }
                                  spec = {
                                      serviceAccountName = "production-stack-controller-manager"
                                      terminationGracePeriodSeconds = 10
                                      securityContext = {
                                          runAsNonRoot = True
                                          seccompProfile.type = "RuntimeDefault"
                                      }
                                      containers = [{
                                          name = "manager"
                                          image = "lmcache/production-stack-operator:2025-12-12"
                                          imagePullPolicy = "IfNotPresent"
                                          command = ["/manager"]
                                          args = ["--metrics-bind-address=:8443", "--leader-elect", "--health-probe-bind-address=:8081"]
                                          livenessProbe = {
                                              httpGet = { path = "/healthz", port = 8081 }
                                              initialDelaySeconds = 15
                                              periodSeconds = 20
                                          }
                                          readinessProbe = {
                                              httpGet = { path = "/readyz", port = 8081 }
                                              initialDelaySeconds = 5
                                              periodSeconds = 10
                                          }
                                          resources = {
                                              limits = { cpu = "500m", memory = "128Mi" }
                                              requests = { cpu = "10m", memory = "64Mi" }
                                          }
                                          securityContext = {
                                              allowPrivilegeEscalation = False
                                              capabilities.drop = ["ALL"]
                                          }
                                      }]
                                  }
                              }
                          }
                      }
                  }
                  usage { _nameSuffix = "app-vllm-op-deploy" }

              if oxr.spec.parameters?.apps?.externalSecrets?.enabled and oxr.spec.parameters.apps?.externalSecrets?.store:
                  object {
                      _name = "secret-store"
                      _externalName = oxr.spec.crossplane.compositionSelector.matchLabels.provider
                      _manifest = {
                          apiVersion = "external-secrets.io/v1beta1"
                          kind = "ClusterSecretStore"
                          metadata.name = oxr.spec.crossplane.compositionSelector.matchLabels.provider
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                              spec.provider.gcpsm.auth.secretRef.secretAccessKeySecretRef = {
                                  name: "gcp-creds"
                                  key: oxr.spec.parameters.apps.externalSecrets.googleCredentialsKey
                                  namespace: oxr.spec.parameters.creds.namespace
                              }
                          elif oxr.spec.crossplane.compositionSelector.matchLabels.provider == "azure":
                              spec.provider.azurekv = {
                                  authType = "ManagedIdentity"
                                  vaultUrl = oxr.spec.parameters.apps.externalSecrets.azureVaultUrl
                              }
                          elif oxr.spec.crossplane.compositionSelector.matchLabels.provider == "aws":
                              spec.provider.aws = {
                                  service = "SecretsManager"
                                  region = "us-east-1"
                                  auth.secretRef = {
                                      accessKeyIDSecretRef = {
                                          name = oxr.spec.parameters.creds.name
                                          key = oxr.spec.parameters.apps.externalSecrets.awsAccessKeyIDKey
                                          namespace = oxr.spec.parameters.creds.namespace
                                      }
                                      secretAccessKeySecretRef = {
                                          name = oxr.spec.parameters.creds.name
                                          key = oxr.spec.parameters.apps.externalSecrets.awsSecretAccessKeyKey
                                          namespace = oxr.spec.parameters.creds.namespace
                                      }
                                  }
                              }
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          _references = [{
                              patchesFrom = {
                                  apiVersion = "gcp.m.upbound.io/v1beta1"
                                  kind = "ProviderConfig"
                                  name = "default"
                                  fieldPath = "spec.projectID"
                              }
                              toFieldPath = "spec.provider.gcpsm.projectID"
                          }]
                  }
                  usage { _nameSuffix = "secret-store" }

          ]

          if oxr.spec.parameters?.apps?.externalSecrets?.secrets:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-secret-" + _secret.toSecret
                      annotations = {
                          "crossplane.io/external-name" = _secret.toSecret
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-secret-" + _secret.toSecret
                      }
                  }
                  spec = {
                      forProvider.manifest = {
                          apiVersion = "external-secrets.io/v1beta1"
                          kind = "ExternalSecret"
                          metadata = {
                              name: _secret.toSecret
                              namespace: _secret.toNamespace
                          }
                          spec = {
                              refreshInterval = "1h"
                              secretStoreRef = {
                                  kind: "ClusterSecretStore"
                                  name: oxr.spec.crossplane.compositionSelector.matchLabels.provider
                              }
                              target = {
                                  name = _secret.toSecret
                                  creationPolicy = "Owner"
                                  template.type = _secret.type
                              }
                              dataFrom = [{ extract.key = _secret.fromSecret }]
                          }
                      }
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              } for _secret in oxr.spec.parameters.apps.externalSecrets.secrets ]
              _items += [{
                  apiVersion = "protection.crossplane.io/v1beta1"
                  kind = "Usage"
                  metadata = {
                      name = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                      }
                  }
                  spec = {
                      of = {
                          apiVersion = "container.gcp.m.upbound.io/v1beta1"
                          kind = "Cluster"
                          resourceRef.name = oxr.metadata.name
                      }
                      by = {
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                          kind = "Object"
                          resourceRef.name = oxr.metadata.name + "-secret-" + _secret.toSecret
                      }
                  }
              } for _secret in oxr.spec.parameters.apps.externalSecrets.secrets ]

          if oxr.spec.parameters?.namespaces:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-ns-" + _namespace
                      annotations = {
                          "crossplane.io/external-name" = _namespace
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-ns-" + _namespace
                      }
                  }
                  spec = {
                      forProvider.manifest = {
                          apiVersion = "v1"
                          kind = "Namespace"
                          metadata.name = _namespace
                      }
                      managementPolicies = ["Create", "Update", "Observe"]
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              } for _namespace in oxr.spec.parameters.namespaces ]

          if oxr.spec.parameters?.creds:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-creds"
                      annotations = {
                          "crossplane.io/external-name" = oxr.spec.parameters.creds.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-creds"
                      }
                  }
                  spec = {
                      references = [{
                          patchesFrom = {
                              apiVersion = "v1"
                              kind = "Secret"
                              name: oxr.spec.parameters.creds.name
                              namespace: oxr.spec.parameters.creds.namespace
                              fieldPath: "data." + _credReference
                          }
                          toFieldPath: "data." + _credReference
                      } for _credReference in oxr.spec.parameters.creds.keys]
                      forProvider = {
                          manifest = {
                              apiVersion = "v1"
                              kind = "Secret"
                              metadata = {
                                  name = oxr.spec.parameters.creds.name
                                  namespace = oxr.spec.parameters.creds.namespace
                              }
                          }
                      }
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              }]
              _items += [{
                  apiVersion = "protection.crossplane.io/v1beta1"
                  kind = "Usage"
                  metadata = {
                      name = oxr.metadata.name + "-creds-usage"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name + "-creds-usage"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-creds-usage"
                      }
                  }
                  spec = {
                      of = {
                          apiVersion = "container.gcp.m.upbound.io/v1beta1"
                          kind = "Cluster"
                          resourceRef.name = oxr.metadata.name
                      }
                      by = {
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                          kind = "Object"
                          resourceRef.name = oxr.metadata.name + "-creds"
                      }
                  }
              }]

          items = _items
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    cluster: aks
    provider: azure
  name: cluster-azure
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.ai/v2
    kind: Cluster
  mode: Pipeline
  pipeline:
  - step: azure
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _metadata = lambda suffix: str -> any {
              {
                  name = oxr.metadata.name
                  annotations = {
                      "crossplane.io/external-name" = oxr.metadata.name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + suffix
                  }
              }
          }

          _items = [{
              apiVersion = "azure.m.upbound.io/v1beta1"
              kind = "ResourceGroup"
              metadata = _metadata("resource-group")
              spec = {
                  forProvider.location = "eastus"
                  initProvider = {}
              }
          }, {
              apiVersion = "containerservice.azure.m.upbound.io/v1beta1"
              kind = "KubernetesCluster"
              metadata = _metadata("cluster")
              spec = {
                  forProvider: {
                      resourceGroupName = oxr.metadata.name
                      if oxr.spec.parameters.version:
                          kubernetesVersion = oxr.spec.parameters.version
                      location = "eastus"
                      dnsPrefix = "dot"
                      defaultNodePool = {
                          name = "nodepool1"
                          if oxr.spec.parameters.nodeSize == "small":
                              vmSize = "Standard_D2_v2"
                          elif oxr.spec.parameters.nodeSize == "medium":
                              vmSize = "Standard_D3_v2"
                          else:
                              vmSize = "Standard_D4_v2"
                          minCount = oxr.spec.parameters.minNodeCount
                          maxCount = 10
                          autoScalingEnabled = True
                      }
                      identity = {type = "SystemAssigned"}
                      networkProfile = {networkPlugin = "none"}
                  }
                  writeConnectionSecretToRef = {
                      name = oxr.metadata.name + "-cluster"
                  }
              }
          }, {
              **oxr
              status.clusterName = oxr.metadata.name
              if oxr.metadata.name + "-cluster" in ocds:
                  status.controlPlaneStatus = ocds[oxr.metadata.name + "-cluster"].Resource.status.conditions[0].reason
                  status.nodePoolStatus = ocds[oxr.metadata.name + "-cluster"].Resource.status.conditions[0].reason
          }]

          _gpu_node_size = oxr.spec.parameters?.gpu?.nodeSize or "small"

          if oxr.spec.parameters?.gpu?.enabled:
              _items += [{
                  apiVersion = "containerservice.azure.m.upbound.io/v1beta1"
                  kind = "KubernetesClusterNodePool"
                  metadata = {
                      name = oxr.metadata.name + "-gpu"
                      annotations = {
                          "crossplane.io/external-name" = "gpu"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-gpu"
                      }
                  }
                  spec = {
                      forProvider = {
                          kubernetesClusterIdSelector.matchControllerRef = True
                          if _gpu_node_size == "small":
                              vmSize = "Standard_NC4as_T4_v3"
                          elif _gpu_node_size == "medium":
                              vmSize = "Standard_NC64as_T4_v3"
                          else:
                              vmSize = "Standard_ND96asr_v4"
                          autoScalingEnabled = True
                          minCount = oxr.spec.parameters?.gpu?.minNodeCount or 1
                          maxCount = oxr.spec.parameters?.gpu?.maxNodeCount or 10
                          nodeLabels = {
                              gpu = "true"
                          }
                          nodeTaints = [
                              "nvidia.com/gpu=true:NoSchedule"
                          ]
                      }
                  }
              }]

          items = _items
  - step: apps
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        source: |
          crossplane = "2.1.4"
          argocd = "9.4.1"
          dapr = "1.16.8"
          traefik = "39.0.0"
          externalSecrets = "2.0.0"
          cilium = "1.19.0"
          nvidiaGpuOperator = "v25.10.1"
          openFunctionUrl = "https://openfunction.github.io/charts/openfunction-v1.2.0-v0.7.0.tgz"

          oxr = option("params").oxr
          ocds = option("params").ocds

          _metadata = lambda suffix: str -> any {
              {
                  name = oxr.metadata.name
                  annotations = {
                      "crossplane.io/external-name" = oxr.metadata.name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + suffix
                  }
              }
          }

          schema usage:
              _nameSuffix: str
              _kind: str = "Object"
              apiVersion = "protection.crossplane.io/v1beta1"
              kind = "Usage"
              metadata = {
                  name = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "crossplane.io/external-name" = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                  }
              }
              spec = {
                  of = {
                      apiVersion = "containerservice.azure.m.upbound.io/v1beta1"
                      kind = "KubernetesCluster"
                      resourceRef.name = oxr.metadata.name
                  }
                  by = {
                      if _kind == "Object":
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                      elif _kind == "Release":
                          apiVersion = "helm.m.crossplane.io/v1beta1"
                      kind = _kind
                      resourceRef.name = oxr.metadata.name + "-" + _nameSuffix
                  }
              }

          schema chart:
              _name: str
              _chartName?: str
              _chartRepository?: str
              _chartVersion?: str
              _chartUrl?: str
              _namespace: str
              _values?: any
              _providerConfigRefName?: str
              apiVersion = "helm.m.crossplane.io/v1beta1"
              kind = "Release"
              metadata = {
                  name = oxr.metadata.name + "-app-" + _name
                  annotations = {
                      "crossplane.io/external-name" = _name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-" + _name
                  }
              }
              spec = {
                  forProvider = {
                      chart = {
                          if _chartName:
                              name = _chartName
                          else:
                              name = _name
                          if _chartRepository:
                              repository = _chartRepository
                          if _chartVersion:
                              version = _chartVersion
                          if _chartUrl:
                              url = _chartUrl
                      }
                      if _values:
                          values = _values
                      namespace = _namespace
                  }
                  managementPolicies = ["Create", "Update", "Observe"]
                  rollbackLimit = 3
                  if _providerConfigRefName:
                      providerConfigRef = {name = _providerConfigRefName, kind = "ProviderConfig"}
                  else:
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
              }

          schema object:
              _name: str
              _externalName?: str
              _manifest: any
              _references?: []
              apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
              kind = "Object"
              metadata = {
                  name = oxr.metadata.name + "-app-" + _name
                  annotations = {
                      if _externalName:
                          "crossplane.io/external-name" = _externalName
                      else:
                          "crossplane.io/external-name" = _name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-" + _name
                  }
              }
              spec = {
                  if _references:
                      references = _references
                  forProvider.manifest = _manifest
                  providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
              }

          _items = [

              {
                  apiVersion = "helm.m.crossplane.io/v1beta1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-helm"
                      }
                  }
                  spec = {
                      credentials = {
                          secretRef = {
                              namespace = oxr.metadata.namespace
                              key = "kubeconfig"
                              name = oxr.metadata.name + "-cluster"
                          }
                          source = "Secret"
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          identity = {
                              type = "GoogleApplicationCredentials"
                              source = "Secret"
                              secretRef = {
                                  name = "gcp-creds"
                                  namespace = "crossplane-system"
                                  key = "creds"
                              }
                          }
                  }
              }

              {
                  apiVersion = "helm.m.crossplane.io/v1beta1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name + "-local"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-helm-local"
                      }
                  }
                  spec.credentials.source = "InjectedIdentity"
              }

              if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "aws":
                  {
                      apiVersion = "helm.m.crossplane.io/v1beta1"
                      kind = "Release"
                      metadata = {
                          name = oxr.metadata.name + "-cilium"
                          annotations = {
                              "crossplane.io/external-name" = "cilium"
                              "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-cilium"
                          }
                      }
                      spec = {
                          forProvider = {
                              chart = {
                                  name = "cilium"
                                  repository = "https://helm.cilium.io"
                                  version = cilium
                              }
                              set = [
                                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                                      {name = "nodeinit.enabled", value = "true"}
                                      {name = "nodeinit.reconfigureKubelet", value = "true"}
                                      {name = "nodeinit.removeCbrBridge", value = "true"}
                                      {name = "cni.binPath", value = "/home/kubernetes/bin"}
                                      {name = "gke.enabled", value = "true"}
                                      {name = "ipam.mode", value = "kubernetes"}
                                      {
                                          name = "ipv4NativeRoutingCIDR"
                                          if oxr.metadata.name + "-nodepool" in ocds:
                                              value = oxr.status.field1
                                      },
                                      {name = "authentication.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.install.enabled", value = "true"}
                                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "azure":
                                      {name = "aksbyocni.enabled", value = "true"}
                                      {name = "nodeinit.enabled", value = "true"}
                                      {name = "authentication.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.install.enabled", value = "true"}
                              ]
                              namespace = "kube-system"
                          }
                          rollbackLimit = 3
                          providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                      }
                  }
                  usage { _nameSuffix = "cilium", _kind = "Release" }

              {
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-kubernetes"
                      }
                  }
                  spec = {
                      credentials = {
                          secretRef = {
                              key = "kubeconfig"
                              name = oxr.metadata.name + "-cluster"
                              namespace = oxr.metadata.namespace
                          }
                          source: "Secret"
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          identity = {
                              type = "GoogleApplicationCredentials"
                              source = "Secret"
                              secretRef = {
                                  name = "gcp-creds"
                                  namespace = "crossplane-system"
                                  key = "creds"
                              }
                          }
                  }
              }

              if oxr.spec.parameters?.apps?.crossplane?.enabled:
                  chart {
                      _name = "crossplane"
                      _chartRepository = "https://charts.crossplane.io/stable"
                      _chartVersion = crossplane
                      _namespace = "crossplane-system"
                  }
                  usage { _nameSuffix = "crossplane", _kind = "Release" }

              if oxr.spec.parameters?.apps?.argocd?.enabled:
                  chart {
                      _name = "argo-cd"
                      _chartRepository = "https://argoproj.github.io/argo-helm"
                      _chartVersion = argocd
                      _namespace = "argocd"
                      _values = {
                          global.domain = oxr.spec.parameters.apps.argocd.host
                          configs = {
                              secret = {
                                  argocdServerAdminPassword = "$2a$10$m3eTlEdRen0nS86c5Zph5u/bDFQMcWZYdG3NVdiyaACCqoxLJaz16"
                                  argocdServerAdminPasswordMtime = "2021-11-08T15:04:05Z"
                              }
                              cm = {
                                  "application.resourceTrackingMethod" = "annotation"
                                  "timeout.reconciliation" = "60s"
                              }
                              params = {
                                  "server.insecure" = True
                              }
                          }
                          server = {
                              if oxr.spec.parameters?.apps?.traefik?.enabled:
                                  ingress = {
                                      enabled = True
                                      ingressClassName = "traefik"
                                  }
                              extraArgs = ["--insecure"]
                          }
                      }
                  }
                  object {
                      _name = "argo-cd-app"
                      _manifest = {
                          apiVersion = "argoproj.io/v1alpha1"
                          kind = "Application"
                          metadata = {
                              name = "apps"
                              namespace = "argocd"
                              finalizers = ["resources-finalizer.argocd.argoproj.io"]
                          }
                          spec = {
                              project = "default"
                              source = {
                                  repoURL = oxr.spec.parameters.apps.argocd.repoURL
                                  targetRevision = "HEAD"
                                  path = oxr.spec.parameters.apps.argocd.sourcePath
                              }
                              destination = {
                                  server = "https://kubernetes.default.svc"
                                  namespace = oxr.spec.parameters.apps.argocd.destinationNamespace
                              }
                              syncPolicy.automated = {
                                  selfHeal = True
                                  prune = True
                                  allowEmpty = True
                              }
                          }
                      }
                  }
                  usage { _nameSuffix = "argo-cd", _kind = "Release" }
                  usage { _nameSuffix = "argo-cd-app" }

              if oxr.spec.parameters?.apps?.openfunction?.enabled:
                  chart {
                      _name = "openfunction"
                      _chartUrl = openFunctionUrl
                      _namespace = "openfunction"
                      _values = {
                          revisionController.enable = True
                      }
                  }
                  usage { _nameSuffix = "openfunction", _kind = "Release" }

              if oxr.spec.parameters?.apps?.dapr?.enabled:
                  chart {
                      _name = "dapr"
                      _chartRepository = "https://dapr.github.io/helm-charts/"
                      _chartVersion = dapr
                      _namespace = "dapr-system"
                  }
                  usage { _nameSuffix = "dapr", _kind = "Release" }

              if oxr.spec.parameters?.apps?.traefik?.enabled:
                  chart {
                      _name = "traefik"
                      _chartRepository = "https://helm.traefik.io/traefik"
                      _chartVersion = traefik
                      _namespace = "traefik"
                  }
                  usage { _nameSuffix = "traefik", _kind = "Release" }

              if oxr.spec.parameters?.apps?.externalSecrets?.enabled:
                  chart {
                      _name = "external-secrets"
                      _chartRepository = "https://charts.external-secrets.io"
                      _chartVersion = externalSecrets
                      _namespace = "external-secrets"
                      _values = {
                          installCRDs = True
                      }
                  }
                  usage { _nameSuffix = "external-secrets", _kind = "Release" }

              if oxr.spec.parameters?.apps?.nvidia?.enabled:
                  chart {
                      _name = "gpu-operator"
                      _chartRepository = "https://helm.ngc.nvidia.com/nvidia"
                      _chartVersion = nvidiaGpuOperator
                      _namespace = "gpu-operator"
                      _values = {
                          driver.enabled = False
                      }
                  }
                  usage { _nameSuffix = "gpu-operator", _kind = "Release" }

              if oxr.spec.parameters?.apps?.vllm?.enabled:
                  object {
                      _name = "vllm-op-ns"
                      _externalName = "production-stack-system"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "Namespace"
                          metadata = {
                              name = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-cacheservers"
                      _externalName = "cacheservers.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "cacheservers.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "CacheServer", listKind = "CacheServerList", plural = "cacheservers", singular = "cacheserver" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  additionalPrinterColumns = [
                                      { name = "Status", type = "string", jsonPath = ".status.status" }
                                      { name = "Age", type = "date", jsonPath = ".metadata.creationTimestamp" }
                                  ]
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-loraadapters"
                      _externalName = "loraadapters.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "loraadapters.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "LoraAdapter", listKind = "LoraAdapterList", plural = "loraadapters", singular = "loraadapter" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  additionalPrinterColumns = [
                                      { name = "Phase", type = "string", jsonPath = ".status.phase" }
                                      { name = "Age", type = "date", jsonPath = ".metadata.creationTimestamp" }
                                  ]
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-vllmrouters"
                      _externalName = "vllmrouters.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "vllmrouters.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "VLLMRouter", listKind = "VLLMRouterList", plural = "vllmrouters", singular = "vllmrouter" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-vllmruntimes"
                      _externalName = "vllmruntimes.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "vllmruntimes.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "VLLMRuntime", listKind = "VLLMRuntimeList", plural = "vllmruntimes", shortNames = ["vr"], singular = "vllmruntime" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  schema.openAPIV3Schema = {
                                      type = "object"
                                      "x-kubernetes-preserve-unknown-fields" = True
                                      properties.spec = {
                                          type = "object"
                                          "x-kubernetes-preserve-unknown-fields" = True
                                          properties.vllmConfig = {
                                              type = "object"
                                              "x-kubernetes-preserve-unknown-fields" = True
                                              properties.port = {
                                                  type = "integer"
                                                  format = "int32"
                                                  default = 8000
                                              }
                                          }
                                      }
                                  }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-sa"
                      _externalName = "production-stack-controller-manager"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "ServiceAccount"
                          metadata = {
                              name = "production-stack-controller-manager"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-role"
                      _externalName = "production-stack-leader-election-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "Role"
                          metadata = {
                              name = "production-stack-leader-election-role"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          rules = [
                              { apiGroups = [""], resources = ["configmaps"], verbs = ["get", "list", "watch", "create", "update", "patch", "delete"] }
                              { apiGroups = ["coordination.k8s.io"], resources = ["leases"], verbs = ["get", "list", "watch", "create", "update", "patch", "delete"] }
                              { apiGroups = [""], resources = ["events"], verbs = ["create", "patch"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-manager"
                      _externalName = "production-stack-manager-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-manager-role"
                          rules = [
                              { apiGroups = [""], resources = ["configmaps", "persistentvolumeclaims", "secrets", "serviceaccounts", "services"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = [""], resources = ["pods"], verbs = ["get", "list", "watch"] }
                              { apiGroups = ["apps"], resources = ["deployments"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["networking.k8s.io"], resources = ["ingresses"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers", "loraadapters", "vllmrouters", "vllmruntimes"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers/finalizers", "loraadapters/finalizers", "vllmrouters/finalizers", "vllmruntimes/finalizers"], verbs = ["update"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers/status", "loraadapters/status", "vllmrouters/status", "vllmruntimes/status"], verbs = ["get", "patch", "update"] }
                              { apiGroups = ["rbac.authorization.k8s.io"], resources = ["rolebindings", "roles"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-metrics-auth"
                      _externalName = "production-stack-metrics-auth-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-metrics-auth-role"
                          rules = [
                              { apiGroups = ["authentication.k8s.io"], resources = ["tokenreviews"], verbs = ["create"] }
                              { apiGroups = ["authorization.k8s.io"], resources = ["subjectaccessreviews"], verbs = ["create"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-metrics-reader"
                      _externalName = "production-stack-metrics-reader"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-metrics-reader"
                          rules = [{ nonResourceURLs = ["/metrics"], verbs = ["get"] }]
                      }
                  }
                  object {
                      _name = "vllm-op-rb"
                      _externalName = "production-stack-leader-election-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "RoleBinding"
                          metadata = {
                              name = "production-stack-leader-election-rolebinding"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "Role", name = "production-stack-leader-election-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-crb-manager"
                      _externalName = "production-stack-manager-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRoleBinding"
                          metadata = {
                              name = "production-stack-manager-rolebinding"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "ClusterRole", name = "production-stack-manager-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-crb-metrics"
                      _externalName = "production-stack-metrics-auth-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRoleBinding"
                          metadata.name = "production-stack-metrics-auth-rolebinding"
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "ClusterRole", name = "production-stack-metrics-auth-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-svc"
                      _externalName = "production-stack-controller-manager-metrics-service"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "Service"
                          metadata = {
                              name = "production-stack-controller-manager-metrics-service"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                          spec = {
                              ports = [{ name = "https", port = 8443, protocol = "TCP", targetPort = 8443 }]
                              selector = {
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-deploy"
                      _externalName = "production-stack-production-stack-controller-manager"
                      _manifest = {
                          apiVersion = "apps/v1"
                          kind = "Deployment"
                          metadata = {
                              name = "production-stack-production-stack-controller-manager"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/component" = "manager"
                                  "app.kubernetes.io/created-by" = "production-stack"
                                  "app.kubernetes.io/instance" = "production-stack"
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "app.kubernetes.io/part-of" = "production-stack"
                              }
                          }
                          spec = {
                              selector.matchLabels = {
                                  "app.kubernetes.io/component" = "manager"
                                  "app.kubernetes.io/instance" = "production-stack"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                              template = {
                                  metadata.labels = {
                                      "app.kubernetes.io/component" = "manager"
                                      "app.kubernetes.io/instance" = "production-stack"
                                      "app.kubernetes.io/name" = "production-stack"
                                      "control-plane" = "controller-manager"
                                  }
                                  spec = {
                                      serviceAccountName = "production-stack-controller-manager"
                                      terminationGracePeriodSeconds = 10
                                      securityContext = {
                                          runAsNonRoot = True
                                          seccompProfile.type = "RuntimeDefault"
                                      }
                                      containers = [{
                                          name = "manager"
                                          image = "lmcache/production-stack-operator:2025-12-12"
                                          imagePullPolicy = "IfNotPresent"
                                          command = ["/manager"]
                                          args = ["--metrics-bind-address=:8443", "--leader-elect", "--health-probe-bind-address=:8081"]
                                          livenessProbe = {
                                              httpGet = { path = "/healthz", port = 8081 }
                                              initialDelaySeconds = 15
                                              periodSeconds = 20
                                          }
                                          readinessProbe = {
                                              httpGet = { path = "/readyz", port = 8081 }
                                              initialDelaySeconds = 5
                                              periodSeconds = 10
                                          }
                                          resources = {
                                              limits = { cpu = "500m", memory = "128Mi" }
                                              requests = { cpu = "10m", memory = "64Mi" }
                                          }
                                          securityContext = {
                                              allowPrivilegeEscalation = False
                                              capabilities.drop = ["ALL"]
                                          }
                                      }]
                                  }
                              }
                          }
                      }
                  }
                  usage { _nameSuffix = "app-vllm-op-deploy" }

              if oxr.spec.parameters?.apps?.externalSecrets?.enabled and oxr.spec.parameters.apps?.externalSecrets?.store:
                  object {
                      _name = "secret-store"
                      _externalName = oxr.spec.crossplane.compositionSelector.matchLabels.provider
                      _manifest = {
                          apiVersion = "external-secrets.io/v1beta1"
                          kind = "ClusterSecretStore"
                          metadata.name = oxr.spec.crossplane.compositionSelector.matchLabels.provider
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                              spec.provider.gcpsm.auth.secretRef.secretAccessKeySecretRef = {
                                  name: "gcp-creds"
                                  key: oxr.spec.parameters.apps.externalSecrets.googleCredentialsKey
                                  namespace: oxr.spec.parameters.creds.namespace
                              }
                          elif oxr.spec.crossplane.compositionSelector.matchLabels.provider == "azure":
                              spec.provider.azurekv = {
                                  authType = "ManagedIdentity"
                                  vaultUrl = oxr.spec.parameters.apps.externalSecrets.azureVaultUrl
                              }
                          elif oxr.spec.crossplane.compositionSelector.matchLabels.provider == "aws":
                              spec.provider.aws = {
                                  service = "SecretsManager"
                                  region = "us-east-1"
                                  auth.secretRef = {
                                      accessKeyIDSecretRef = {
                                          name = oxr.spec.parameters.creds.name
                                          key = oxr.spec.parameters.apps.externalSecrets.awsAccessKeyIDKey
                                          namespace = oxr.spec.parameters.creds.namespace
                                      }
                                      secretAccessKeySecretRef = {
                                          name = oxr.spec.parameters.creds.name
                                          key = oxr.spec.parameters.apps.externalSecrets.awsSecretAccessKeyKey
                                          namespace = oxr.spec.parameters.creds.namespace
                                      }
                                  }
                              }
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          _references = [{
                              patchesFrom = {
                                  apiVersion = "gcp.m.upbound.io/v1beta1"
                                  kind = "ProviderConfig"
                                  name = "default"
                                  fieldPath = "spec.projectID"
                              }
                              toFieldPath = "spec.provider.gcpsm.projectID"
                          }]
                  }
                  usage { _nameSuffix = "secret-store" }

          ]

          if oxr.spec.parameters?.apps?.externalSecrets?.secrets:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-secret-" + _secret.toSecret
                      annotations = {
                          "crossplane.io/external-name" = _secret.toSecret
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-secret-" + _secret.toSecret
                      }
                  }
                  spec = {
                      forProvider.manifest = {
                          apiVersion = "external-secrets.io/v1beta1"
                          kind = "ExternalSecret"
                          metadata = {
                              name: _secret.toSecret
                              namespace: _secret.toNamespace
                          }
                          spec = {
                              refreshInterval = "1h"
                              secretStoreRef = {
                                  kind: "ClusterSecretStore"
                                  name: oxr.spec.crossplane.compositionSelector.matchLabels.provider
                              }
                              target = {
                                  name = _secret.toSecret
                                  creationPolicy = "Owner"
                                  template.type = _secret.type
                              }
                              dataFrom = [{ extract.key = _secret.fromSecret }]
                          }
                      }
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              } for _secret in oxr.spec.parameters.apps.externalSecrets.secrets ]
              _items += [{
                  apiVersion = "protection.crossplane.io/v1beta1"
                  kind = "Usage"
                  metadata = {
                      name = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                      }
                  }
                  spec = {
                      of = {
                          apiVersion = "containerservice.azure.m.upbound.io/v1beta1"
                          kind = "KubernetesCluster"
                          resourceRef.name = oxr.metadata.name
                      }
                      by = {
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                          kind = "Object"
                          resourceRef.name = oxr.metadata.name + "-secret-" + _secret.toSecret
                      }
                  }
              } for _secret in oxr.spec.parameters.apps.externalSecrets.secrets ]

          if oxr.spec.parameters?.namespaces:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-ns-" + _namespace
                      annotations = {
                          "crossplane.io/external-name" = _namespace
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-ns-" + _namespace
                      }
                  }
                  spec = {
                      forProvider.manifest = {
                          apiVersion = "v1"
                          kind = "Namespace"
                          metadata.name = _namespace
                      }
                      managementPolicies = ["Create", "Update", "Observe"]
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              } for _namespace in oxr.spec.parameters.namespaces ]

          if oxr.spec.parameters?.creds:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-creds"
                      annotations = {
                          "crossplane.io/external-name" = oxr.spec.parameters.creds.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-creds"
                      }
                  }
                  spec = {
                      references = [{
                          patchesFrom = {
                              apiVersion = "v1"
                              kind = "Secret"
                              name: oxr.spec.parameters.creds.name
                              namespace: oxr.spec.parameters.creds.namespace
                              fieldPath: "data." + _credReference
                          }
                          toFieldPath: "data." + _credReference
                      } for _credReference in oxr.spec.parameters.creds.keys]
                      forProvider = {
                          manifest = {
                              apiVersion = "v1"
                              kind = "Secret"
                              metadata = {
                                  name = oxr.spec.parameters.creds.name
                                  namespace = oxr.spec.parameters.creds.namespace
                              }
                          }
                      }
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              }]
              _items += [{
                  apiVersion = "protection.crossplane.io/v1beta1"
                  kind = "Usage"
                  metadata = {
                      name = oxr.metadata.name + "-creds-usage"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name + "-creds-usage"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-creds-usage"
                      }
                  }
                  spec = {
                      of = {
                          apiVersion = "containerservice.azure.m.upbound.io/v1beta1"
                          kind = "KubernetesCluster"
                          resourceRef.name = oxr.metadata.name
                      }
                      by = {
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                          kind = "Object"
                          resourceRef.name = oxr.metadata.name + "-creds"
                      }
                  }
              }]

          items = _items
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    cluster: eks
    provider: aws
  name: cluster-aws
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.ai/v2
    kind: Cluster
  mode: Pipeline
  pipeline:
  - step: aws
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _metadata = lambda name: str, suffix: str, role: str -> any {
              {
                  if name != "":
                      name = oxr.metadata.name + "-" + name
                  else:
                      name = oxr.metadata.name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = suffix
                  }
                  if role != "":
                      labels.role = oxr.metadata.name + "-" + role
              }
          }

          _items = [{
              apiVersion = "eks.aws.m.upbound.io/v1beta1"
              kind = "Cluster"
              metadata = _metadata("", "ekscluster", "")
              spec.forProvider: {
                  region = "us-east-1"
                  bootstrapSelfManagedAddons = True
                  if oxr.spec.parameters.version:
                      version = oxr.spec.parameters.version
                  roleArnSelector = {
                      matchControllerRef = True
                      matchLabels.role = oxr.metadata.name + "-controlplane"
                  }
                  vpcConfig = {
                      endpointPrivateAccess = True
                      endpointPublicAccess = True
                      subnetIdSelector.matchControllerRef = True
                  }
              }
          }, {
              apiVersion = "eks.aws.m.upbound.io/v1beta1"
              kind = "ClusterAuth"
              metadata = _metadata("", "clusterAuth", "")
              spec = {
                  forProvider: {
                      region = "us-east-1"
                      clusterNameSelector.matchControllerRef = True
                  }
                  writeConnectionSecretToRef = {
                      name = oxr.metadata.name + "-cluster"
                  }
              }
          }, {
              apiVersion = "eks.aws.m.upbound.io/v1beta1"
              kind = "NodeGroup"
              metadata = _metadata("", "eksnodegroup", "")
              spec = {
                  forProvider = {
                      region = "us-east-1"
                      clusterNameSelector.matchControllerRef = True
                      nodeRoleArnSelector = {
                          matchControllerRef = True
                          matchLabels.role = oxr.metadata.name + "-nodegroup"
                      }
                      subnetIdSelector.matchControllerRef = True
                      scalingConfig = {
                          minSize = oxr.spec.parameters.minNodeCount
                          maxSize = 10
                          desiredSize = oxr.spec.parameters.minNodeCount
                      }
                      if oxr.spec.parameters.nodeSize == "small":
                          instanceTypes = ["t3.small"]
                      elif oxr.spec.parameters.nodeSize == "medium":
                          instanceTypes = ["t3.medium"]
                      else:
                          instanceTypes = ["t3.large"]
                  }
              }
          }, {
              apiVersion = "ec2.aws.m.upbound.io/v1beta1"
              kind = "VPC"
              metadata = _metadata("", "vpc-nodepool", "")
              spec = {
                  forProvider = {
                      region = "us-east-1"
                      cidrBlock = "10.0.0.0/16"
                      enableDnsSupport = True
                  }
              }
          }, {
              apiVersion: "ec2.aws.m.upbound.io/v1beta1"
              kind: "SecurityGroup"
              metadata = _metadata("", "sg-nodepool", "")
              spec.forProvider: {
                  name = oxr.metadata.name
                  description = "Cluster communication with worker nodes"
                  region = "us-east-1"
                  vpcIdSelector.matchControllerRef = True
              }
          }, {
              apiVersion = "ec2.aws.m.upbound.io/v1beta1"
              kind = "SecurityGroupRule"
              metadata = _metadata("", "securityGroupRule", "")
              spec.forProvider: {
                  description = "I am too lazy to write descriptions"
                  region = "us-east-1"
                  type = "egress"
                  fromPort = 0
                  toPort = 0
                  protocol = "-1"
                  cidrBlocks = ["0.0.0.0/0"]
                  securityGroupIdSelector.matchControllerRef = True
              }
          }, {
              apiVersion = "ec2.aws.m.upbound.io/v1beta1"
              kind = "InternetGateway"
              metadata = _metadata("", "gateway", "")
              spec.forProvider = {
                  region = "us-east-1"
                  vpcIdSelector.matchControllerRef = True
              }
          }, {
              apiVersion = "ec2.aws.m.upbound.io/v1beta1"
              kind = "RouteTable"
              metadata = _metadata("", "routeTable", "")
              spec.forProvider: {
                  region = "us-east-1"
                  vpcIdSelector.matchControllerRef = True
              }
          }, {
              apiVersion: "ec2.aws.m.upbound.io/v1beta1"
              kind: "Route"
              metadata = _metadata("", "route", "")
              spec.forProvider: {
                  region = "us-east-1"
                  routeTableIdSelector.matchControllerRef = True
                  destinationCidrBlock = "0.0.0.0/0"
                  gatewayIdSelector.matchControllerRef = True
              }
          }, {
              apiVersion: "ec2.aws.m.upbound.io/v1beta1"
              kind: "MainRouteTableAssociation"
              metadata = _metadata("", "mainRouteTableAssociation", "")
              spec.forProvider: {
                  region = "us-east-1"
                  routeTableIdSelector.matchControllerRef = True
                  vpcIdSelector.matchControllerRef = True
              }
          }, {
              apiVersion = "eks.aws.m.upbound.io/v1beta1"
              kind = "Addon"
              metadata = _metadata("ebs", "addonEbs", "")
              spec.forProvider = {
                  addonName = "aws-ebs-csi-driver"
                  region = "us-east-1"
                  clusterNameSelector.matchControllerRef = True
              }
          }, {
              **oxr
              status.clusterName = oxr.metadata.name
              if "ekscluster" in ocds:
                  status.controlPlaneStatus = ocds["ekscluster"].Resource.status.conditions[0].reason
              if "eksnodegroup" in ocds:
                  status.nodePoolStatus = ocds["eksnodegroup"].Resource.status.conditions[0].reason
          }]

          _zones = [
              {suffix = "1a", ip = "10.0.0.0/24"}
              {suffix = "1b", ip = "10.0.1.0/24"},
              {suffix = "1c", ip = "10.0.2.0/24"}
          ]

          _items += [{
              apiVersion = "ec2.aws.m.upbound.io/v1beta1"
              kind = "RouteTableAssociation"
              metadata = _metadata(_zone.suffix, "routeTableAssociation" + _zone.suffix, "")
              spec.forProvider: {
                  region = "us-east-1"
                  routeTableIdSelector.matchControllerRef = True
                  subnetIdSelector = {
                      matchControllerRef = True
                      matchLabels = {
                          zone = "us-east-" + _zone.suffix
                          access = "public"
                      }
                  }
              }
          } for _zone in _zones]

          _items += [{
              apiVersion = "ec2.aws.m.upbound.io/v1beta1"
              kind = "Subnet"
              metadata = {
                  name = oxr.metadata.name + "-" + _zone.suffix
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = "subnet-nodepool-" + _zone.suffix
                  }
                  labels = {
                      zone = "us-east-" + _zone.suffix
                      access: "public"
                  }
              }
              spec: {
                  forProvider = {
                      region = "us-east-1"
                      availabilityZone = "us-east-" + _zone.suffix
                      cidrBlock = _zone.ip
                      vpcIdSelector.matchControllerRef = True
                      mapPublicIpOnLaunch = True
                      tags = {
                          "kubernetes.io/role/elb": "1"
                      }
                  }
              }
          } for _zone in _zones]

          _rpas = [
              {name = "controlplane", role = "controlplane", policyArn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"}
              {name = "service", role = "controlplane", policyArn = "arn:aws:iam::aws:policy/AmazonEKSServicePolicy"}
              {name = "worker", role = "nodegroup", policyArn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"}
              {name = "cni", role = "nodegroup", policyArn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"}
              {name = "registry", role = "nodegroup", policyArn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"}
          ]

          _items += [{
              apiVersion = "iam.aws.m.upbound.io/v1beta1"
              kind = "RolePolicyAttachment"
              metadata = _metadata(_rpa.name, "iamattachment-" + _rpa.name, "")
              spec = {
                  forProvider = {
                      policyArn = _rpa.policyArn
                      roleSelector = {
                          matchControllerRef = True
                          matchLabels.role = oxr.metadata.name + "-" + _rpa.role
                      }
                  }
              }
          } for _rpa in _rpas]

          _roles = [
              {name = "controlplane", service = "eks"}
              {name = "nodegroup", service = "ec2"}
          ]

          _items += [{
              apiVersion = "iam.aws.m.upbound.io/v1beta1"
              kind = "Role"
              metadata = {
                  name = oxr.metadata.name + "-" + _role.name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = "iamrole-" + _role.name
                  }
                  labels.role = oxr.metadata.name + "-" + _role.name
              }
              spec.forProvider.assumeRolePolicy = """\
          {
            "Version": "2012-10-17",
            "Statement": [{
              "Effect": "Allow",
              "Principal": {"Service": [\"""" + _role.service + """.amazonaws.com"]},
              "Action": ["sts:AssumeRole"]
            }]
          }
          """
          } for _role in _roles]

          _gpu_node_size = oxr.spec.parameters?.gpu?.nodeSize or "small"

          if oxr.spec.parameters?.gpu?.enabled:
              _items += [{
                  apiVersion = "eks.aws.m.upbound.io/v1beta1"
                  kind = "NodeGroup"
                  metadata = _metadata("gpu", "eksnodegroup-gpu", "")
                  spec = {
                      forProvider = {
                          region = "us-east-1"
                          clusterNameSelector.matchControllerRef = True
                          nodeRoleArnSelector = {
                              matchControllerRef = True
                              matchLabels.role = oxr.metadata.name + "-nodegroup"
                          }
                          subnetIdSelector.matchControllerRef = True
                          amiType = "AL2023_x86_64_NVIDIA"
                          scalingConfig = {
                              minSize = oxr.spec.parameters?.gpu?.minNodeCount or 1
                              maxSize = oxr.spec.parameters?.gpu?.maxNodeCount or 10
                              desiredSize = oxr.spec.parameters?.gpu?.minNodeCount or 1
                          }
                          if _gpu_node_size == "small":
                              instanceTypes = ["g5.xlarge"]
                          elif _gpu_node_size == "medium":
                              instanceTypes = ["g5.12xlarge"]
                          else:
                              instanceTypes = ["p4d.24xlarge"]
                          labels = {
                              gpu = "true"
                          }
                          taint = [{
                              effect = "NO_SCHEDULE"
                              key = "nvidia.com/gpu"
                              value = "true"
                          }]
                      }
                  }
              }]

          items = _items
  - step: apps
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        source: |
          crossplane = "2.1.4"
          argocd = "9.4.1"
          dapr = "1.16.8"
          traefik = "39.0.0"
          externalSecrets = "2.0.0"
          cilium = "1.19.0"
          nvidiaGpuOperator = "v25.10.1"
          openFunctionUrl = "https://openfunction.github.io/charts/openfunction-v1.2.0-v0.7.0.tgz"

          oxr = option("params").oxr
          ocds = option("params").ocds

          _metadata = lambda suffix: str -> any {
              {
                  name = oxr.metadata.name
                  annotations = {
                      "crossplane.io/external-name" = oxr.metadata.name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + suffix
                  }
              }
          }

          schema usage:
              _nameSuffix: str
              _kind: str = "Object"
              apiVersion = "protection.crossplane.io/v1beta1"
              kind = "Usage"
              metadata = {
                  name = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "crossplane.io/external-name" = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-" + _nameSuffix + "-usage"
                  }
              }
              spec = {
                  of = {
                      apiVersion = "eks.aws.m.upbound.io/v1beta1"
                      kind = "Cluster"
                      resourceRef.name = oxr.metadata.name
                  }
                  by = {
                      if _kind == "Object":
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                      elif _kind == "Release":
                          apiVersion = "helm.m.crossplane.io/v1beta1"
                      kind = _kind
                      resourceRef.name = oxr.metadata.name + "-" + _nameSuffix
                  }
              }

          schema chart:
              _name: str
              _chartName?: str
              _chartRepository?: str
              _chartVersion?: str
              _chartUrl?: str
              _namespace: str
              _values?: any
              _providerConfigRefName?: str
              apiVersion = "helm.m.crossplane.io/v1beta1"
              kind = "Release"
              metadata = {
                  name = oxr.metadata.name + "-app-" + _name
                  annotations = {
                      "crossplane.io/external-name" = _name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-" + _name
                  }
              }
              spec = {
                  forProvider = {
                      chart = {
                          if _chartName:
                              name = _chartName
                          else:
                              name = _name
                          if _chartRepository:
                              repository = _chartRepository
                          if _chartVersion:
                              version = _chartVersion
                          if _chartUrl:
                              url = _chartUrl
                      }
                      if _values:
                          values = _values
                      namespace = _namespace
                  }
                  managementPolicies = ["Create", "Update", "Observe"]
                  rollbackLimit = 3
                  if _providerConfigRefName:
                      providerConfigRef = {name = _providerConfigRefName, kind = "ProviderConfig"}
                  else:
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
              }

          schema object:
              _name: str
              _externalName?: str
              _manifest: any
              _references?: []
              apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
              kind = "Object"
              metadata = {
                  name = oxr.metadata.name + "-app-" + _name
                  annotations = {
                      if _externalName:
                          "crossplane.io/external-name" = _externalName
                      else:
                          "crossplane.io/external-name" = _name
                      "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-" + _name
                  }
              }
              spec = {
                  if _references:
                      references = _references
                  forProvider.manifest = _manifest
                  providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
              }

          _items = [

              {
                  apiVersion = "helm.m.crossplane.io/v1beta1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-helm"
                      }
                  }
                  spec = {
                      credentials = {
                          secretRef = {
                              namespace = oxr.metadata.namespace
                              key = "kubeconfig"
                              name = oxr.metadata.name + "-cluster"
                          }
                          source = "Secret"
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          identity = {
                              type = "GoogleApplicationCredentials"
                              source = "Secret"
                              secretRef = {
                                  name = "gcp-creds"
                                  namespace = "crossplane-system"
                                  key = "creds"
                              }
                          }
                  }
              }

              {
                  apiVersion = "helm.m.crossplane.io/v1beta1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name + "-local"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-helm-local"
                      }
                  }
                  spec.credentials.source = "InjectedIdentity"
              }

              if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "aws":
                  {
                      apiVersion = "helm.m.crossplane.io/v1beta1"
                      kind = "Release"
                      metadata = {
                          name = oxr.metadata.name + "-cilium"
                          annotations = {
                              "crossplane.io/external-name" = "cilium"
                              "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-app-cilium"
                          }
                      }
                      spec = {
                          forProvider = {
                              chart = {
                                  name = "cilium"
                                  repository = "https://helm.cilium.io"
                                  version = cilium
                              }
                              set = [
                                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                                      {name = "nodeinit.enabled", value = "true"}
                                      {name = "nodeinit.reconfigureKubelet", value = "true"}
                                      {name = "nodeinit.removeCbrBridge", value = "true"}
                                      {name = "cni.binPath", value = "/home/kubernetes/bin"}
                                      {name = "gke.enabled", value = "true"}
                                      {name = "ipam.mode", value = "kubernetes"}
                                      {
                                          name = "ipv4NativeRoutingCIDR"
                                          if oxr.metadata.name + "-nodepool" in ocds:
                                              value = oxr.status.field1
                                      },
                                      {name = "authentication.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.install.enabled", value = "true"}
                                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "azure":
                                      {name = "aksbyocni.enabled", value = "true"}
                                      {name = "nodeinit.enabled", value = "true"}
                                      {name = "authentication.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.enabled", value = "true"}
                                      {name = "authentication.mutual.spire.install.enabled", value = "true"}
                              ]
                              namespace = "kube-system"
                          }
                          rollbackLimit = 3
                          providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                      }
                  }
                  usage { _nameSuffix = "cilium", _kind = "Release" }

              {
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "ProviderConfig"
                  metadata = {
                      name = oxr.metadata.name
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-config-kubernetes"
                      }
                  }
                  spec = {
                      credentials = {
                          secretRef = {
                              key = "kubeconfig"
                              name = oxr.metadata.name + "-cluster"
                              namespace = oxr.metadata.namespace
                          }
                          source: "Secret"
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          identity = {
                              type = "GoogleApplicationCredentials"
                              source = "Secret"
                              secretRef = {
                                  name = "gcp-creds"
                                  namespace = "crossplane-system"
                                  key = "creds"
                              }
                          }
                  }
              }

              if oxr.spec.parameters?.apps?.crossplane?.enabled:
                  chart {
                      _name = "crossplane"
                      _chartRepository = "https://charts.crossplane.io/stable"
                      _chartVersion = crossplane
                      _namespace = "crossplane-system"
                  }
                  usage { _nameSuffix = "crossplane", _kind = "Release" }

              if oxr.spec.parameters?.apps?.argocd?.enabled:
                  chart {
                      _name = "argo-cd"
                      _chartRepository = "https://argoproj.github.io/argo-helm"
                      _chartVersion = argocd
                      _namespace = "argocd"
                      _values = {
                          global.domain = oxr.spec.parameters.apps.argocd.host
                          configs = {
                              secret = {
                                  argocdServerAdminPassword = "$2a$10$m3eTlEdRen0nS86c5Zph5u/bDFQMcWZYdG3NVdiyaACCqoxLJaz16"
                                  argocdServerAdminPasswordMtime = "2021-11-08T15:04:05Z"
                              }
                              cm = {
                                  "application.resourceTrackingMethod" = "annotation"
                                  "timeout.reconciliation" = "60s"
                              }
                              params = {
                                  "server.insecure" = True
                              }
                          }
                          server = {
                              if oxr.spec.parameters?.apps?.traefik?.enabled:
                                  ingress = {
                                      enabled = True
                                      ingressClassName = "traefik"
                                  }
                              extraArgs = ["--insecure"]
                          }
                      }
                  }
                  object {
                      _name = "argo-cd-app"
                      _manifest = {
                          apiVersion = "argoproj.io/v1alpha1"
                          kind = "Application"
                          metadata = {
                              name = "apps"
                              namespace = "argocd"
                              finalizers = ["resources-finalizer.argocd.argoproj.io"]
                          }
                          spec = {
                              project = "default"
                              source = {
                                  repoURL = oxr.spec.parameters.apps.argocd.repoURL
                                  targetRevision = "HEAD"
                                  path = oxr.spec.parameters.apps.argocd.sourcePath
                              }
                              destination = {
                                  server = "https://kubernetes.default.svc"
                                  namespace = oxr.spec.parameters.apps.argocd.destinationNamespace
                              }
                              syncPolicy.automated = {
                                  selfHeal = True
                                  prune = True
                                  allowEmpty = True
                              }
                          }
                      }
                  }
                  usage { _nameSuffix = "argo-cd", _kind = "Release" }
                  usage { _nameSuffix = "argo-cd-app" }

              if oxr.spec.parameters?.apps?.openfunction?.enabled:
                  chart {
                      _name = "openfunction"
                      _chartUrl = openFunctionUrl
                      _namespace = "openfunction"
                      _values = {
                          revisionController.enable = True
                      }
                  }
                  usage { _nameSuffix = "openfunction", _kind = "Release" }

              if oxr.spec.parameters?.apps?.dapr?.enabled:
                  chart {
                      _name = "dapr"
                      _chartRepository = "https://dapr.github.io/helm-charts/"
                      _chartVersion = dapr
                      _namespace = "dapr-system"
                  }
                  usage { _nameSuffix = "dapr", _kind = "Release" }

              if oxr.spec.parameters?.apps?.traefik?.enabled:
                  chart {
                      _name = "traefik"
                      _chartRepository = "https://helm.traefik.io/traefik"
                      _chartVersion = traefik
                      _namespace = "traefik"
                  }
                  usage { _nameSuffix = "traefik", _kind = "Release" }

              if oxr.spec.parameters?.apps?.externalSecrets?.enabled:
                  chart {
                      _name = "external-secrets"
                      _chartRepository = "https://charts.external-secrets.io"
                      _chartVersion = externalSecrets
                      _namespace = "external-secrets"
                      _values = {
                          installCRDs = True
                      }
                  }
                  usage { _nameSuffix = "external-secrets", _kind = "Release" }

              if oxr.spec.parameters?.apps?.nvidia?.enabled:
                  chart {
                      _name = "gpu-operator"
                      _chartRepository = "https://helm.ngc.nvidia.com/nvidia"
                      _chartVersion = nvidiaGpuOperator
                      _namespace = "gpu-operator"
                      _values = {
                          driver.enabled = False
                      }
                  }
                  usage { _nameSuffix = "gpu-operator", _kind = "Release" }

              if oxr.spec.parameters?.apps?.vllm?.enabled:
                  object {
                      _name = "vllm-op-ns"
                      _externalName = "production-stack-system"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "Namespace"
                          metadata = {
                              name = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-cacheservers"
                      _externalName = "cacheservers.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "cacheservers.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "CacheServer", listKind = "CacheServerList", plural = "cacheservers", singular = "cacheserver" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  additionalPrinterColumns = [
                                      { name = "Status", type = "string", jsonPath = ".status.status" }
                                      { name = "Age", type = "date", jsonPath = ".metadata.creationTimestamp" }
                                  ]
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-loraadapters"
                      _externalName = "loraadapters.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "loraadapters.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "LoraAdapter", listKind = "LoraAdapterList", plural = "loraadapters", singular = "loraadapter" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  additionalPrinterColumns = [
                                      { name = "Phase", type = "string", jsonPath = ".status.phase" }
                                      { name = "Age", type = "date", jsonPath = ".metadata.creationTimestamp" }
                                  ]
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-vllmrouters"
                      _externalName = "vllmrouters.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "vllmrouters.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "VLLMRouter", listKind = "VLLMRouterList", plural = "vllmrouters", singular = "vllmrouter" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  schema.openAPIV3Schema = { type = "object", "x-kubernetes-preserve-unknown-fields" = True }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-crd-vllmruntimes"
                      _externalName = "vllmruntimes.production-stack.vllm.ai"
                      _manifest = {
                          apiVersion = "apiextensions.k8s.io/v1"
                          kind = "CustomResourceDefinition"
                          metadata.name = "vllmruntimes.production-stack.vllm.ai"
                          spec = {
                              group = "production-stack.vllm.ai"
                              names = { kind = "VLLMRuntime", listKind = "VLLMRuntimeList", plural = "vllmruntimes", shortNames = ["vr"], singular = "vllmruntime" }
                              scope = "Namespaced"
                              versions = [{
                                  name = "v1alpha1"
                                  served = True
                                  storage = True
                                  subresources.status = {}
                                  schema.openAPIV3Schema = {
                                      type = "object"
                                      "x-kubernetes-preserve-unknown-fields" = True
                                      properties.spec = {
                                          type = "object"
                                          "x-kubernetes-preserve-unknown-fields" = True
                                          properties.vllmConfig = {
                                              type = "object"
                                              "x-kubernetes-preserve-unknown-fields" = True
                                              properties.port = {
                                                  type = "integer"
                                                  format = "int32"
                                                  default = 8000
                                              }
                                          }
                                      }
                                  }
                              }]
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-sa"
                      _externalName = "production-stack-controller-manager"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "ServiceAccount"
                          metadata = {
                              name = "production-stack-controller-manager"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-role"
                      _externalName = "production-stack-leader-election-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "Role"
                          metadata = {
                              name = "production-stack-leader-election-role"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          rules = [
                              { apiGroups = [""], resources = ["configmaps"], verbs = ["get", "list", "watch", "create", "update", "patch", "delete"] }
                              { apiGroups = ["coordination.k8s.io"], resources = ["leases"], verbs = ["get", "list", "watch", "create", "update", "patch", "delete"] }
                              { apiGroups = [""], resources = ["events"], verbs = ["create", "patch"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-manager"
                      _externalName = "production-stack-manager-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-manager-role"
                          rules = [
                              { apiGroups = [""], resources = ["configmaps", "persistentvolumeclaims", "secrets", "serviceaccounts", "services"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = [""], resources = ["pods"], verbs = ["get", "list", "watch"] }
                              { apiGroups = ["apps"], resources = ["deployments"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["networking.k8s.io"], resources = ["ingresses"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers", "loraadapters", "vllmrouters", "vllmruntimes"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers/finalizers", "loraadapters/finalizers", "vllmrouters/finalizers", "vllmruntimes/finalizers"], verbs = ["update"] }
                              { apiGroups = ["production-stack.vllm.ai"], resources = ["cacheservers/status", "loraadapters/status", "vllmrouters/status", "vllmruntimes/status"], verbs = ["get", "patch", "update"] }
                              { apiGroups = ["rbac.authorization.k8s.io"], resources = ["rolebindings", "roles"], verbs = ["create", "delete", "get", "list", "patch", "update", "watch"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-metrics-auth"
                      _externalName = "production-stack-metrics-auth-role"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-metrics-auth-role"
                          rules = [
                              { apiGroups = ["authentication.k8s.io"], resources = ["tokenreviews"], verbs = ["create"] }
                              { apiGroups = ["authorization.k8s.io"], resources = ["subjectaccessreviews"], verbs = ["create"] }
                          ]
                      }
                  }
                  object {
                      _name = "vllm-op-cr-metrics-reader"
                      _externalName = "production-stack-metrics-reader"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRole"
                          metadata.name = "production-stack-metrics-reader"
                          rules = [{ nonResourceURLs = ["/metrics"], verbs = ["get"] }]
                      }
                  }
                  object {
                      _name = "vllm-op-rb"
                      _externalName = "production-stack-leader-election-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "RoleBinding"
                          metadata = {
                              name = "production-stack-leader-election-rolebinding"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "Role", name = "production-stack-leader-election-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-crb-manager"
                      _externalName = "production-stack-manager-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRoleBinding"
                          metadata = {
                              name = "production-stack-manager-rolebinding"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                          }
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "ClusterRole", name = "production-stack-manager-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-crb-metrics"
                      _externalName = "production-stack-metrics-auth-rolebinding"
                      _manifest = {
                          apiVersion = "rbac.authorization.k8s.io/v1"
                          kind = "ClusterRoleBinding"
                          metadata.name = "production-stack-metrics-auth-rolebinding"
                          roleRef = { apiGroup = "rbac.authorization.k8s.io", kind = "ClusterRole", name = "production-stack-metrics-auth-role" }
                          subjects = [{ kind = "ServiceAccount", name = "production-stack-controller-manager", namespace = "production-stack-system" }]
                      }
                  }
                  object {
                      _name = "vllm-op-svc"
                      _externalName = "production-stack-controller-manager-metrics-service"
                      _manifest = {
                          apiVersion = "v1"
                          kind = "Service"
                          metadata = {
                              name = "production-stack-controller-manager-metrics-service"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                          spec = {
                              ports = [{ name = "https", port = 8443, protocol = "TCP", targetPort = 8443 }]
                              selector = {
                                  "app.kubernetes.io/name" = "production-stack"
                                  "control-plane" = "controller-manager"
                              }
                          }
                      }
                  }
                  object {
                      _name = "vllm-op-deploy"
                      _externalName = "production-stack-production-stack-controller-manager"
                      _manifest = {
                          apiVersion = "apps/v1"
                          kind = "Deployment"
                          metadata = {
                              name = "production-stack-production-stack-controller-manager"
                              namespace = "production-stack-system"
                              labels = {
                                  "app.kubernetes.io/component" = "manager"
                                  "app.kubernetes.io/created-by" = "production-stack"
                                  "app.kubernetes.io/instance" = "production-stack"
                                  "app.kubernetes.io/managed-by" = "kustomize"
                                  "app.kubernetes.io/name" = "production-stack"
                                  "app.kubernetes.io/part-of" = "production-stack"
                              }
                          }
                          spec = {
                              selector.matchLabels = {
                                  "app.kubernetes.io/component" = "manager"
                                  "app.kubernetes.io/instance" = "production-stack"
                                  "app.kubernetes.io/name" = "production-stack"
                              }
                              template = {
                                  metadata.labels = {
                                      "app.kubernetes.io/component" = "manager"
                                      "app.kubernetes.io/instance" = "production-stack"
                                      "app.kubernetes.io/name" = "production-stack"
                                      "control-plane" = "controller-manager"
                                  }
                                  spec = {
                                      serviceAccountName = "production-stack-controller-manager"
                                      terminationGracePeriodSeconds = 10
                                      securityContext = {
                                          runAsNonRoot = True
                                          seccompProfile.type = "RuntimeDefault"
                                      }
                                      containers = [{
                                          name = "manager"
                                          image = "lmcache/production-stack-operator:2025-12-12"
                                          imagePullPolicy = "IfNotPresent"
                                          command = ["/manager"]
                                          args = ["--metrics-bind-address=:8443", "--leader-elect", "--health-probe-bind-address=:8081"]
                                          livenessProbe = {
                                              httpGet = { path = "/healthz", port = 8081 }
                                              initialDelaySeconds = 15
                                              periodSeconds = 20
                                          }
                                          readinessProbe = {
                                              httpGet = { path = "/readyz", port = 8081 }
                                              initialDelaySeconds = 5
                                              periodSeconds = 10
                                          }
                                          resources = {
                                              limits = { cpu = "500m", memory = "128Mi" }
                                              requests = { cpu = "10m", memory = "64Mi" }
                                          }
                                          securityContext = {
                                              allowPrivilegeEscalation = False
                                              capabilities.drop = ["ALL"]
                                          }
                                      }]
                                  }
                              }
                          }
                      }
                  }
                  usage { _nameSuffix = "app-vllm-op-deploy" }

              if oxr.spec.parameters?.apps?.externalSecrets?.enabled and oxr.spec.parameters.apps?.externalSecrets?.store:
                  object {
                      _name = "secret-store"
                      _externalName = oxr.spec.crossplane.compositionSelector.matchLabels.provider
                      _manifest = {
                          apiVersion = "external-secrets.io/v1beta1"
                          kind = "ClusterSecretStore"
                          metadata.name = oxr.spec.crossplane.compositionSelector.matchLabels.provider
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                              spec.provider.gcpsm.auth.secretRef.secretAccessKeySecretRef = {
                                  name: "gcp-creds"
                                  key: oxr.spec.parameters.apps.externalSecrets.googleCredentialsKey
                                  namespace: oxr.spec.parameters.creds.namespace
                              }
                          elif oxr.spec.crossplane.compositionSelector.matchLabels.provider == "azure":
                              spec.provider.azurekv = {
                                  authType = "ManagedIdentity"
                                  vaultUrl = oxr.spec.parameters.apps.externalSecrets.azureVaultUrl
                              }
                          elif oxr.spec.crossplane.compositionSelector.matchLabels.provider == "aws":
                              spec.provider.aws = {
                                  service = "SecretsManager"
                                  region = "us-east-1"
                                  auth.secretRef = {
                                      accessKeyIDSecretRef = {
                                          name = oxr.spec.parameters.creds.name
                                          key = oxr.spec.parameters.apps.externalSecrets.awsAccessKeyIDKey
                                          namespace = oxr.spec.parameters.creds.namespace
                                      }
                                      secretAccessKeySecretRef = {
                                          name = oxr.spec.parameters.creds.name
                                          key = oxr.spec.parameters.apps.externalSecrets.awsSecretAccessKeyKey
                                          namespace = oxr.spec.parameters.creds.namespace
                                      }
                                  }
                              }
                      }
                      if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "google":
                          _references = [{
                              patchesFrom = {
                                  apiVersion = "gcp.m.upbound.io/v1beta1"
                                  kind = "ProviderConfig"
                                  name = "default"
                                  fieldPath = "spec.projectID"
                              }
                              toFieldPath = "spec.provider.gcpsm.projectID"
                          }]
                  }
                  usage { _nameSuffix = "secret-store" }

          ]

          if oxr.spec.parameters?.apps?.externalSecrets?.secrets:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-secret-" + _secret.toSecret
                      annotations = {
                          "crossplane.io/external-name" = _secret.toSecret
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-secret-" + _secret.toSecret
                      }
                  }
                  spec = {
                      forProvider.manifest = {
                          apiVersion = "external-secrets.io/v1beta1"
                          kind = "ExternalSecret"
                          metadata = {
                              name: _secret.toSecret
                              namespace: _secret.toNamespace
                          }
                          spec = {
                              refreshInterval = "1h"
                              secretStoreRef = {
                                  kind: "ClusterSecretStore"
                                  name: oxr.spec.crossplane.compositionSelector.matchLabels.provider
                              }
                              target = {
                                  name = _secret.toSecret
                                  creationPolicy = "Owner"
                                  template.type = _secret.type
                              }
                              dataFrom = [{ extract.key = _secret.fromSecret }]
                          }
                      }
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              } for _secret in oxr.spec.parameters.apps.externalSecrets.secrets ]
              _items += [{
                  apiVersion = "protection.crossplane.io/v1beta1"
                  kind = "Usage"
                  metadata = {
                      name = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-secret-" + _secret.toSecret + "-usage"
                      }
                  }
                  spec = {
                      of = {
                          apiVersion = "eks.aws.m.upbound.io/v1beta1"
                          kind = "Cluster"
                          resourceRef.name = oxr.metadata.name
                      }
                      by = {
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                          kind = "Object"
                          resourceRef.name = oxr.metadata.name + "-secret-" + _secret.toSecret
                      }
                  }
              } for _secret in oxr.spec.parameters.apps.externalSecrets.secrets ]

          if oxr.spec.parameters?.namespaces:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-ns-" + _namespace
                      annotations = {
                          "crossplane.io/external-name" = _namespace
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-ns-" + _namespace
                      }
                  }
                  spec = {
                      forProvider.manifest = {
                          apiVersion = "v1"
                          kind = "Namespace"
                          metadata.name = _namespace
                      }
                      managementPolicies = ["Create", "Update", "Observe"]
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              } for _namespace in oxr.spec.parameters.namespaces ]

          if oxr.spec.parameters?.creds:
              _items += [{
                  apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                  kind = "Object"
                  metadata = {
                      name = oxr.metadata.name + "-creds"
                      annotations = {
                          "crossplane.io/external-name" = oxr.spec.parameters.creds.name
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-creds"
                      }
                  }
                  spec = {
                      references = [{
                          patchesFrom = {
                              apiVersion = "v1"
                              kind = "Secret"
                              name: oxr.spec.parameters.creds.name
                              namespace: oxr.spec.parameters.creds.namespace
                              fieldPath: "data." + _credReference
                          }
                          toFieldPath: "data." + _credReference
                      } for _credReference in oxr.spec.parameters.creds.keys]
                      forProvider = {
                          manifest = {
                              apiVersion = "v1"
                              kind = "Secret"
                              metadata = {
                                  name = oxr.spec.parameters.creds.name
                                  namespace = oxr.spec.parameters.creds.namespace
                              }
                          }
                      }
                      providerConfigRef = {name = oxr.metadata.name, kind = "ProviderConfig"}
                  }
              }]
              _items += [{
                  apiVersion = "protection.crossplane.io/v1beta1"
                  kind = "Usage"
                  metadata = {
                      name = oxr.metadata.name + "-creds-usage"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "crossplane.io/external-name" = oxr.metadata.name + "-creds-usage"
                          "krm.kcl.dev/composition-resource-name" = oxr.metadata.name + "-creds-usage"
                      }
                  }
                  spec = {
                      of = {
                          apiVersion = "eks.aws.m.upbound.io/v1beta1"
                          kind = "Cluster"
                          resourceRef.name = oxr.metadata.name
                      }
                      by = {
                          apiVersion = "kubernetes.m.crossplane.io/v1alpha1"
                          kind = "Object"
                          resourceRef.name = oxr.metadata.name + "-creds"
                      }
                  }
              }]

          items = _items
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
